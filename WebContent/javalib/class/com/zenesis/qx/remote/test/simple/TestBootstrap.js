/**
 * Class generated by Qoxodoo Server Objects com.zenesis.qx.remote.ClassWriter
 * 
 * @use(com.zenesis.qx.remote.test.collections.TestQsoArrayList)
 * @use(com.zenesis.qx.remote.test.multiuser.TestThreading)
 * @use(com.zenesis.qx.remote.test.collections.TestRecursiveArray)
 * @use(com.zenesis.qx.remote.test.multiuser.TestMultiUser)
 * @use(com.zenesis.qx.remote.test.collections.TestQsoMap)
 * @use(com.zenesis.qx.remote.test.simple.MainTests)
 * @use(com.zenesis.qx.remote.test.simple.TestObserver)
 */

qx.Class.define("com.zenesis.qx.remote.test.simple.TestBootstrap", {
  "extend" : qx.core.Object,
  "implement" : [ com.zenesis.qx.remote.LogEntrySink ],
  "construct" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    args.unshift(arguments);
    this.base.apply(this, args);
    this.initialiseProxy();
 },
  "properties" : {
    "threadTest" : {
      "@" : [ new com.zenesis.qx.remote.annotations.Property().set({
  "readOnly" : true
}) ],
      "nullable" : true,
      "apply":"_applyThreadTest",
      "check":"com.zenesis.qx.remote.test.multiuser.TestThreading",
      "event":"changeThreadTest"
    },
    "recursiveArray" : {
      "nullable" : true,
      "apply":"_applyRecursiveArray",
      "check":"com.zenesis.qx.remote.test.collections.TestRecursiveArray",
      "event":"changeRecursiveArray"
    },
    "multiUser" : {
      "@" : [ new com.zenesis.qx.remote.annotations.Property().set({
  "readOnly" : true
}) ],
      "nullable" : true,
      "apply":"_applyMultiUser",
      "check":"com.zenesis.qx.remote.test.multiuser.TestMultiUser",
      "event":"changeMultiUser"
    }
  },
  "members" : {
    "addLogEntries" : function() {
    return this._callServer("addLogEntries", qx.lang.Array.fromArguments(arguments));
 },
    "getMapTestsAsync" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    return new qx.Promise(function(resolve, reject) {
      args.push(function() {
        resolve.apply(this, qx.lang.Array.fromArguments(arguments));
      });
      this._callServer("getMapTests", args);
    }, this);
 },
    "_applyMultiUser" : function(value, oldValue, name) {
    this._applyProperty("multiUser", value, oldValue, name);
 },
    "getMainTestsAsync" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    return new qx.Promise(function(resolve, reject) {
      args.push(function() {
        resolve.apply(this, qx.lang.Array.fromArguments(arguments));
      });
      this._callServer("getMainTests", args);
    }, this);
 },
    "getTestObserverAsync" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    return new qx.Promise(function(resolve, reject) {
      args.push(function() {
        resolve.apply(this, qx.lang.Array.fromArguments(arguments));
      });
      this._callServer("getTestObserver", args);
    }, this);
 },
    "getMainTests" : function() {
    return this._callServer("getMainTests", qx.lang.Array.fromArguments(arguments));
 },
    "getThreadTestAsync" : function() {
    return qx.Promise.resolve(this.getThreadTest()).bind(this);
 },
    "getMultiUserAsync" : function() {
    return qx.Promise.resolve(this.getMultiUser()).bind(this);
 },
    "getArrayListTests" : function() {
    return this._callServer("getArrayListTests", qx.lang.Array.fromArguments(arguments));
 },
    "getArrayListTestsAsync" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    return new qx.Promise(function(resolve, reject) {
      args.push(function() {
        resolve.apply(this, qx.lang.Array.fromArguments(arguments));
      });
      this._callServer("getArrayListTests", args);
    }, this);
 },
    "addLogEntriesAsync" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    return new qx.Promise(function(resolve, reject) {
      args.push(function() {
        resolve.apply(this, qx.lang.Array.fromArguments(arguments));
      });
      this._callServer("addLogEntries", args);
    }, this);
 },
    "testRecursiveArray" : function() {
    return this._callServer("testRecursiveArray", qx.lang.Array.fromArguments(arguments));
 },
    "getRecursiveArrayAsync" : function() {
    return qx.Promise.resolve(this.getRecursiveArray()).bind(this);
 },
    "_applyThreadTest" : function(value, oldValue, name) {
    this._applyProperty("threadTest", value, oldValue, name);
 },
    "getTestObserver" : function() {
    return this._callServer("getTestObserver", qx.lang.Array.fromArguments(arguments));
 },
    "_applyRecursiveArray" : function(value, oldValue, name) {
    this._applyProperty("recursiveArray", value, oldValue, name);
 },
    "testRecursiveArrayAsync" : function() {
    var args = qx.lang.Array.fromArguments(arguments);
    return new qx.Promise(function(resolve, reject) {
      args.push(function() {
        resolve.apply(this, qx.lang.Array.fromArguments(arguments));
      });
      this._callServer("testRecursiveArray", args);
    }, this);
 },
    "getMapTests" : function() {
    return this._callServer("getMapTests", qx.lang.Array.fromArguments(arguments));
 }
  },
  "defer" : function(clazz) {
    clazz.$$eventMeta = {};
    clazz.$$methodMeta = {};
    com.zenesis.qx.remote.MProxy.deferredClassInitialisation(clazz);
    clazz.$$methodMeta.addLogEntries = {
      "isServer" : true
    };
    clazz.$$methodMeta.getArrayListTests = {
      "isServer" : true
    };
    clazz.$$methodMeta.getMainTests = {
      "isServer" : true
    };
    clazz.$$methodMeta.getMapTests = {
      "isServer" : true
    };
    clazz.$$methodMeta.getTestObserver = {
      "isServer" : true,
      "returnType":"com.zenesis.qx.remote.test.simple.TestObserver"
    };
    clazz.$$methodMeta.testRecursiveArray = {
      "isServer" : true
    };
    qx.lang.Object.mergeWith(clazz.$$properties.threadTest, {
      "onDemand" : false,
      "isServer" : true,
      "readOnly" : true,
      "sync":"queue",
      "nativeKeyType" : true
    });
    qx.lang.Object.mergeWith(clazz.$$properties.recursiveArray, {
      "onDemand" : false,
      "isServer" : true,
      "readOnly" : false,
      "sync":"queue",
      "nativeKeyType" : true
    });
    qx.lang.Object.mergeWith(clazz.$$properties.multiUser, {
      "onDemand" : false,
      "isServer" : true,
      "readOnly" : true,
      "sync":"queue",
      "nativeKeyType" : true
    });
    clazz.$$eventMeta.changeRecursiveArray = {
      "isServer" : true,
      "isProperty" : true
    };
    clazz.$$eventMeta.changeMultiUser = {
      "isServer" : true,
      "isProperty" : true
    };
    clazz.$$eventMeta.changeThreadTest = {
      "isServer" : true,
      "isProperty" : true
    };
 }
});
